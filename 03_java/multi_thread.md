# 多线程

## ① 线程死锁的原因和解决办法

原因: **线程互相等待资源，又不释放自身的资源，导致无穷无尽的等待。**

产生死锁的必要条件有四个(4个全部满足才会死锁)：

- 1.**互斥条件**: 所谓互斥就是线程在某一时间内独占资源。
- 2.**请求与保持条件**: 一个线程因请求资源而阻塞时，对已获得的资源保持不放。
- 3.**不剥夺条件**: 线程已获得资源，在末使用完之前，不能强行剥夺。
- 4.**循环等待条件**: 若干线程之间形成一种头尾相接的循环等待资源关系。

预防的具体方法(打破四个必要条件的任意一个)：

- 1 打破*互斥条件*

使资源同时访问而非互斥使用，就没有进程会阻塞在资源上，从而不发生死锁。

> 针对只读文件可以这样操作。

- 2 打破*请求与保持条件*

一次性请求当前线程需要的所有资源, 否则线程不开始执行。

> 实现简单，但是严重的减低了资源利用率。

- 3 打破*不剥夺条件*

占用部分资源的线程进一步申请其他资源时，如果申请不到，就主动释放它占有的资源。

- 4 打破*循环等待条件*

按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

- 4.1 **加锁顺序**(synchronized代码块嵌套)

```java
synchronized(objA){
synchronized(objB){
synchronized(objC){
        // do sth.
        }
        }
        }
```

      - 一个进程得到某层的一个资源后，只能申请较高一层的资源
      - 当进程释放某层的一个资源时，必须先释放所占有的较高层的资源
      - 当进程获得某层的一个资源时，如果想申请同层的另一个资源，必须先释放此层中已占有的资源

- 4.2 **加锁时限**

超过一定时间必释放锁。

- 4.3 **死锁检测**

用于记录线程和锁关系的数据结构(map、graph)。当某个线程请求所失败时，遍历表(map)或图(graph)，检查是否有死锁发生。当检测出有死锁发生的时候：①
释放所有锁，回退，并且等待一段随机的时间后重试; ② 给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。

解决死锁的措施:

- 1 **重启系统。** 代价大。意味着在此之前所有的线程已经完成的计算工作全都白费。
- 2 **撤销线程，剥夺资源。** 终止参与死锁的线程，收回他们所占有的资源，从而解除死锁。这时又分为两种情况:
  一次性撤销参与死锁的线程，剥夺全部资源；或者逐步撤销参与死锁的线程，逐步回收死锁线程占有的资源。一般来说，选择逐步撤销的线程时，要按照一定的原则进行，目的是撤销那些代价最小的线程，比如按线程的优先级确定线程的代价;考虑线程运行时的代价和与此线程相关的外部作业的代价的因素。
- 3 **线程回退策略**
  即让参与死锁的线程回退到发生死锁前的某一处，并由此点处继续执行，以求再次执行时不再发生死锁。虽然这是个较理想的办法，但是操作起来系统开销极大，要有对战记录线程的每一步变化，以便今后的回退，大多数情况下是无法做到的。

## ② wait和sleep有什么区别

**sleep不会释放对象锁。** sleep()方法是线程类（Thread）的静态方法，导致此线程暂停执行指定时间，将执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复（线程回到就绪（ready）状态），因为调用
sleep 不会释放对象锁。

**wait会释放对象锁。** wait() 是 Object 类的方法，对此对象调用 wait()方法导致本线程放弃对象锁(线程暂停执行)
，进入等待此对象的等待锁定池，只有针对此对象发出 notify 方法（或 notifyAll）后本线程才进入对象锁定池准备获得对象锁进入就绪状态。

|       | sleep()       | wait()                                          |
|:------|:--------------|:------------------------------------------------|
| 来源    | Thread的静态方法   | Object的实例方法                                     |
| 释放锁对象 | ❌             | ✅                                               |
| 使用范围  | 任意            | 同步控制方法内 或 同步控制块内;否则IllegalMonitorStateException |
| 用途    | 一定时间内暂停线程执行   | 用于线程间交互和通信                                      |
| 用法    | 指定时间后, 线程自动苏醒 | 需配合notify()/notifyAll()才能唤醒                     |

## ③ volatile关键字的原理

> A Java(TM) programming language keyword used in variable declarations that specifies that the variable is modified
> asynchronously by concurrently running threads.

使用volatile变量可降低内存一致性错误的风险，因为对volatile变量的任何写入都会与该变量的后续读取建立happens-before关系。这意味着对volatile变量的更改始终对其他线程可见。而且，这还意味着，当线程读取一个volatile变量时，它不仅会看到对volatile的最新更改，还会看到导致更改的代码的副作用。

- 能保证原子性吗

  否

- 能保证线程安全吗

  否。必须同时满足下面两个条件才能保证在并发环境的线程安全：

（1）对变量的写操作不依赖于当前值。

（2）该变量没有包含在具有其他变量的不变式中。

## ④ synchronized关键字原理，修饰在不同的地方(静态方法，对象方法)分别是锁什么东西?

静态方法: 当前类的锁。

非静态方法: 当前对象的锁。

结论: 类锁和对象锁不同，他们之间不会产生互斥

### 线程池

### ① 线程池的构造方法的几个参数, 含义作用

```java
// Java线程池的完整构造函数
public ThreadPoolExecutor(
        int corePoolSize, // 线程池长期维持的线程数，即使线程处于Idle状态，也不会回收。
        int maximumPoolSize, // 线程数的上限
        long keepAliveTime,  // 超过corePoolSize的线程的idle时长，
        TimeUnit unit,      // 超过这个时间，多余的线程会被回收。
        BlockingQueue<Runnable> workQueue, // 任务的排队队列
        ThreadFactory threadFactory, // 新线程的产生方式
        RejectedExecutionHandler handler) // 拒绝策略
```

### ② ThreadLocal用过吗？讲讲原理

- ThreadLocal提供了线程的局部变量，每个线程都可以通过`set()`和`get()`来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，
  **实现了线程的数据隔离**～。
- key为当前ThreadLocal对象，value为泛型。
- ThreadLocal内存泄漏的根源:
  **由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用**。

## 线程安全集合类

### HashMap平替

- HashTable(操作方法加synchronized关键字修饰)
- ConcurrentHashMap(锁分片)
  - Segment 继承了 ReentrantLock，所以 Segment 是一种可重入锁，扮演锁的角色。

### ArrayList平替

- Vector(synchronized关键字修饰方法)
- CopyOnWriteArrayList(Lock锁)

### 集合工具
Collections.synchronizedList(list);Collections.synchronizedMap(m)

### ReentrantLock
<sub>re-entrant-lock</sub>  
可重入锁，也叫做 递归锁，从名字上理解，字面意思就是再进入的锁，重入性是指任意线程在获取到锁之后能够再次获取该锁而不会被锁阻塞，首先他需要具备两个条件：

- 线程再次获取锁：所需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次获取成功
- 锁的最终释放：线程重复n次获取了锁，随后在第n次释放该锁后，其它线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前线程被重复获取的次数，而被释放时，计数自减，当计数为0时表示锁已经成功释放。

无参构造方法产生的ReentrantLock是非公平锁。true是公平锁。

## 协程

### ① 用过协程吗？讲讲原理

它提供了轻量级的任务调度机制。协程的目的是在不阻塞线程的情况下实现任务的挂起和恢复。

协程就是一个线程框架。跟Java的Executor; Android的Handler、AsyncTask一样。性能不分上下，但它的优点是写法简单。可以轻松的写出并发的代码。用同步的写法，写出异步的代码。

比其他线程框架的**优势**: 可以在同一个代码块里进行线程的切换(避免回调地狱)

### ② suspend关键字

suspend关键字的作用: 提醒。提醒调用者，我这个函数需要在协程或另一个挂起函数中被调用。它并不起到挂起的功能。

- suspend挂起的是什么?   
  挂起的就是协程。协程所在的线程不再执行协程里的代码了。
- 从哪挂起?   
  从当前线程挂起。
- 什么时候切回来？
  协程在它指定的线程执行完毕后, 会切回它挂起时的线程。(切回来的动作: resume)
- 为什么一个suspend函数必须在协程或者另一个挂起函数中使用？  
  因为协程是需要恢复(resume)的, 一个suspend函数要是不在协程或一个挂起函数中使用, 它就没办法恢复。

### ③ 什么叫「非阻塞」式挂起？

非阻塞式: 不卡线程。用Java的Thread切线程也是非阻塞的。完全一样。

协程的非阻塞是只是一种看起来阻塞实际上不阻塞的写法而已。

CPU的计算耗时 + I/O耗时(和网络的数据交互, 它的等待是因为**网络传输的性能低于CPU的性能**。)

状态机: 有限个状态以及在这些状态之间的转移和动作等行为的数学计算模型。

### NIO和BIO的区别

BIO （Blocking I/O）：同步阻塞 I/O 模式。

NIO （New I/O）：同步非阻塞模式。

AIO （Asynchronous I/O）：异步非阻塞 I/O 模型。

同步阻塞模式：这种模式下，我们的工作模式是先来到厨房，开始烧水，并坐在水壶面前一直等着水烧开。

同步非阻塞模式：这种模式下，我们的工作模式是先来到厨房，开始烧水，但是我们不一直坐在水壶前面等，而是回到客厅看电视，然后每隔几分钟到厨房看一下水有没有烧开。

异步非阻塞 I/O 模型：这种模式下，我们的工作模式是先来到厨房，开始烧水，我们不一直坐在水壶前面等，也不隔一段时间去看一下，而是在客厅看电视，水壶上面有个开关，水烧开之后他会通知我。

### JVM定义了几种线程的状态

NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED

一、新建状态(NEW)
二、运行状态(RUNNABLE) 就绪状态 其他状态->就绪 ...
三、阻塞状态(BLOCKED)
四、等待状态(WAITING) 运行->等待 等待->就绪
五、超时等待状态(TIMED_WAITING) 运行->超时等待 超时等待->就绪
六、消亡状态

| 线程状态          | 	解释                             |
|:--------------|:--------------------------------|
| NEW           | 	尚未启动的线程状态，即线程创建，还未调用start方法    |
| RUNNABLE	     | 就绪状态（调用start，等待调度）+正在运行         |
| BLOCKED	      | 等待监视器锁时，陷入阻塞状态                  |
| WAITING	      | 等待状态的线程正在等待另一线程执行特定的操作（如notify） |
| TIMED_WAITING | 	具有指定等待时间的等待状态                  |
| TERMINATED    | 	线程完成执行，终止状态                    |

![thread_state][thread_state]

[thread_state]: ./art/thread_state.png

[java_guide]: https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E7%9A%84%E6%96%B9%E6%B3%95