# 多线程

## ① 线程死锁的原因和解决办法

原因: **线程互相等待资源，又不释放自身的资源，导致无穷无尽的等待。**

产生死锁的必要条件有四个(4个全部满足才会死锁)：

- 1.**互斥条件**: 所谓互斥就是线程在某一时间内独占资源。
- 2.**请求与保持条件**: 一个线程因请求资源而阻塞时，对已获得的资源保持不放。
- 3.**不剥夺条件**: 线程已获得资源，在末使用完之前，不能强行剥夺。
- 4.**循环等待条件**: 若干线程之间形成一种头尾相接的循环等待资源关系。

预防的具体方法(打破四个必要条件的任意一个)：

- 1 打破*互斥条件*

使资源同时访问而非互斥使用，就没有进程会阻塞在资源上，从而不发生死锁。

> 针对只读文件可以这样操作。

- 2 打破*请求与保持条件*

一次性请求当前线程需要的所有资源, 否则线程不开始执行。

> 实现简单，但是严重的减低了资源利用率。

- 3 打破*不剥夺条件*

占用部分资源的线程进一步申请其他资源时，如果申请不到，就主动释放它占有的资源。

- 4 打破*循环等待条件*

按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

- 4.1 **加锁顺序**(synchronized代码块嵌套)

```java
synchronized(objA){
synchronized(objB){
synchronized(objC){
        // do sth.
        }
        }
        }
```

      - 一个进程得到某层的一个资源后，只能申请较高一层的资源
      - 当进程释放某层的一个资源时，必须先释放所占有的较高层的资源
      - 当进程获得某层的一个资源时，如果想申请同层的另一个资源，必须先释放此层中已占有的资源

- 4.2 **加锁时限**

超过一定时间必释放锁。

- 4.3 **死锁检测**

用于记录线程和锁关系的数据结构(map、graph)。当某个线程请求所失败时，遍历表(map)或图(graph)，检查是否有死锁发生。当检测出有死锁发生的时候：①
释放所有锁，回退，并且等待一段随机的时间后重试; ② 给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。

解决死锁的措施:

- 1 **重启系统。** 代价大。意味着在此之前所有的线程已经完成的计算工作全都白费。
- 2 **撤销线程，剥夺资源。** 终止参与死锁的线程，收回他们所占有的资源，从而解除死锁。这时又分为两种情况:
  一次性撤销参与死锁的线程，剥夺全部资源；或者逐步撤销参与死锁的线程，逐步回收死锁线程占有的资源。一般来说，选择逐步撤销的线程时，要按照一定的原则进行，目的是撤销那些代价最小的线程，比如按线程的优先级确定线程的代价;考虑线程运行时的代价和与此线程相关的外部作业的代价的因素。
- 3 **线程回退策略**
  即让参与死锁的线程回退到发生死锁前的某一处，并由此点处继续执行，以求再次执行时不再发生死锁。虽然这是个较理想的办法，但是操作起来系统开销极大，要有对战记录线程的每一步变化，以便今后的回退，大多数情况下是无法做到的。

## ② wait和sleep有什么区别

**sleep不会释放对象锁。** sleep()方法是线程类（Thread）的静态方法，导致此线程暂停执行指定时间，将执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复（线程回到就绪（ready）状态），因为调用
sleep 不会释放对象锁。

**wait会释放对象锁。** wait() 是 Object 类的方法，对此对象调用 wait()方法导致本线程放弃对象锁(线程暂停执行)
，进入等待此对象的等待锁定池，只有针对此对象发出 notify 方法（或 notifyAll）后本线程才进入对象锁定池准备获得对象锁进入就绪状态。

|       | sleep()       | wait()                                          |
|:------|:--------------|:------------------------------------------------|
| 来源    | Thread的静态方法   | Object的实例方法                                     |
| 释放锁对象 | ❌             | ✅                                               |
| 使用范围  | 任意            | 同步控制方法内 或 同步控制块内;否则IllegalMonitorStateException |
| 用途    | 一定时间内暂停线程执行   | 用于线程间交互和通信                                      |
| 用法    | 指定时间后, 线程自动苏醒 | 需配合notify()/notifyAll()才能唤醒                     |

## ③ volatile关键字的原理

> A Java(TM) programming language keyword used in variable declarations that specifies that the variable is modified
> asynchronously by concurrently running threads.

使用volatile变量可降低内存一致性错误的风险，因为对volatile变量的任何写入都会与该变量的后续读取建立happens-before关系。这意味着对volatile变量的更改始终对其他线程可见。而且，这还意味着，当线程读取一个volatile变量时，它不仅会看到对volatile的最新更改，还会看到导致更改的代码的副作用。

- 能保证原子性吗

  否

- 能保证线程安全吗

  否。必须同时满足下面两个条件才能保证在并发环境的线程安全：

（1）对变量的写操作不依赖于当前值。

（2）该变量没有包含在具有其他变量的不变式中。

## ④ synchronized关键字原理，修饰在不同的地方(静态方法，对象方法)分别是锁什么东西?

静态方法: 当前类的锁。

非静态方法: 当前对象的锁。

结论: 类锁和对象锁不同，他们之间不会产生互斥

### 线程池

### ① 线程池的构造方法的几个参数, 含义作用

```java
// Java线程池的完整构造函数
public ThreadPoolExecutor(
        int corePoolSize, // 线程池长期维持的线程数，即使线程处于Idle状态，也不会回收。
        int maximumPoolSize, // 线程数的上限
        long keepAliveTime,  // 超过corePoolSize的线程的idle时长，
        TimeUnit unit,      // 超过这个时间，多余的线程会被回收。
        BlockingQueue<Runnable> workQueue, // 任务的排队队列
        ThreadFactory threadFactory, // 新线程的产生方式
        RejectedExecutionHandler handler) // 拒绝策略
```

### ② ThreadLocal用过吗？讲讲原理

- ThreadLocal提供了线程的局部变量，每个线程都可以通过`set()`和`get()`来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，
  **实现了线程的数据隔离**～。
- key为当前ThreadLocal对象，value为泛型。
- ThreadLocal内存泄漏的根源:
  **由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用**。

## 线程安全集合类

### HashMap平替

- HashTable(操作方法加synchronized关键字修饰)
- ConcurrentHashMap(锁分片)
    - Segment 继承了 ReentrantLock，所以 Segment 是一种可重入锁，扮演锁的角色。

### ArrayList平替

- Vector(synchronized关键字修饰方法)
- CopyOnWriteArrayList(Lock锁)

### 集合工具

Collections.synchronizedList(list);Collections.synchronizedMap(m)

## 各种类型的锁

乐观锁/悲观锁
- 乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS(Compare and Swap 比较并交换)实现的。
- 悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改自己的数据，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。比如Java里面的同步synchronized关键字的实现就是悲观锁。悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。

独享锁/共享锁。独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。
- 独享锁: 是指该锁一次只能被一个线程所持有，Java ReentrantLock就是独享锁，Synchronized也是独享锁。
- 共享锁: 是指该锁可被多个线程所持有，Java ReadWriteLock其读锁是共享锁，其写锁是独享锁，读锁的共享锁可保证并发读是非常高效的，读写，写读，写写的过程是互斥的。

互斥锁/读写锁
- 互斥锁在Java中的具体实现就是ReentrantLock，
- 读写锁在Java中的具体实现就是ReadWriteLock。

可重入锁
> 可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁，ReetrantLock和Synchronized都是可重入锁。

重入性是指任意线程在获取到锁之后能够再次获取该锁而不会被锁阻塞，首先他需要具备两个条件：
- 线程再次获取锁：所需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次获取成功
- 锁的最终释放：线程重复n次获取了锁，随后在第n次释放该锁后，其它线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前线程被重复获取的次数，而被释放时，计数自减，当计数为0时表示锁已经成功释放。

无参构造方法产生的ReentrantLock是非公平锁。true是公平锁。


公平锁/非公平锁
- 公平锁: 是指多个线程按照申请锁的顺序来获取锁。
- 非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象，Java ReetrantLock是通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大，Synchronized也是非公平锁。

分段锁
- 分段锁其实也是一种设计，并不是具体的一种锁，ConcurrentHashMap就是一种分段锁的设计，，ConcurrentHashMap中的分段锁称为Segment，它类似于HashMap（JDK7和JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表，同时又是一个ReentrantLock（Segment继承了ReentrantLock）；当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在哪一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。

偏向锁/轻量级锁/重量级锁
这三种锁是指锁的状态，并且是针对Synchronized，在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。
- 偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。
- 轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
- 重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级，重量级锁会让他申请的线程进入阻塞，性能降低。

自旋锁

- 在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。

### NIO和BIO的区别

BIO （Blocking I/O）：同步阻塞 I/O 模式。

NIO （New I/O）：同步非阻塞模式。

AIO （Asynchronous I/O）：异步非阻塞 I/O 模型。

同步阻塞模式：这种模式下，我们的工作模式是先来到厨房，开始烧水，并坐在水壶面前一直等着水烧开。

同步非阻塞模式：这种模式下，我们的工作模式是先来到厨房，开始烧水，但是我们不一直坐在水壶前面等，而是回到客厅看电视，然后每隔几分钟到厨房看一下水有没有烧开。

异步非阻塞 I/O 模型：这种模式下，我们的工作模式是先来到厨房，开始烧水，我们不一直坐在水壶前面等，也不隔一段时间去看一下，而是在客厅看电视，水壶上面有个开关，水烧开之后他会通知我。

### JVM定义了几种线程的状态

NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED

一、新建状态(NEW)
二、运行状态(RUNNABLE) 就绪状态 其他状态->就绪 ...
三、阻塞状态(BLOCKED)
四、等待状态(WAITING) 运行->等待 等待->就绪
五、超时等待状态(TIMED_WAITING) 运行->超时等待 超时等待->就绪
六、消亡状态

| 线程状态          | 	解释                             |
|:--------------|:--------------------------------|
| NEW           | 	尚未启动的线程状态，即线程创建，还未调用start方法    |
| RUNNABLE	     | 就绪状态（调用start，等待调度）+正在运行         |
| BLOCKED	      | 等待监视器锁时，陷入阻塞状态                  |
| WAITING	      | 等待状态的线程正在等待另一线程执行特定的操作（如notify） |
| TIMED_WAITING | 	具有指定等待时间的等待状态                  |
| TERMINATED    | 	线程完成执行，终止状态                    |

![thread_state][thread_state]

## Android线程消息

Message
MessageQueue
Looper
Handler

## 周期性任务

Timer。最常用。适用于短周期任务。执行完毕后, 记得timer.cancel(), 否则内存泄漏。

ScheduledExecutorService。比Timer更灵活、更强大。适用于短周期任务。执行完毕后, 记得shutdown()/shutdownNow(), 否则内存泄漏。

AlarmManager, 更高效, 但依赖于系统的闹钟服务, 不适用短期任务(<1天)

## StrictMode

可用于检查线程问题。

[thread_state]: ./art/thread_state.png

[java_guide]: https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E7%9A%84%E6%96%B9%E6%B3%95