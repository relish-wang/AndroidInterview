# 算法与数据结构

[TOC]

## 一、数据结构

### 1 堆排序的实现

完全二叉树

大根堆：父节点的值大于等于左右子节点值

小根堆：父节点的值小于等于左右子节点值

(以大根堆为例)先构建最大堆：

然后对二叉树进行遍历，把根节点从树上取下来。然后比较左右子树节点，较大的那一边的节点成为二叉树的根节点，剩下的重新构建最大堆。依次操作，最初取节点的顺序所对应的值就是从大到小排列的。

### 2 二叉树

#### ① 在二叉树中, 已知两个节点的, 如何找到这两个节点的最小公共父节点

情况一：root未知，但是每个节点都有parent指针
此时可以分别从两个节点开始，沿着parent指针走向根节点，得到两个链表，然后求两个链表的第一个公共节点，这个方法很简单，不需要详细解释的。

情况二：节点只有左、右指针，没有parent指针，root已知
思路：有两种情况，一是要找的这两个节点（a, b），在要遍历的节点（root）的两侧，那么这个节点就是这两个节点的最近公共父节点；
二是两个节点在同一侧，则 root->left 或者 root->right 为 NULL，另一边返回a或者b。那么另一边返回的就是他们的最小公共父节点。
递归有两个出口，一是没有找到a或者b，则返回NULL；二是只要碰到a或者b，就立刻返回。


分两种情况:

1 根节点(root)未知, 节点包含parent指针。

此时可以分别从两个节点开始，沿着parent指针走向根节点，得到两个链表，然后求两个链表的第一个公共节点。

2 根节点(root)已知, 节点仅包含左右节点指针。

有两种情况，一是要找的这两个节点（a, b），在要遍历的节点（root）的两侧，那么这个节点就是这两个节点的最近公共父节点；
二是两个节点在同一侧，则 root->left 或者 root->right 为 NULL，另一边返回a或者b。那么另一边返回的就是他们的最小公共父节点。
递归有两个出口，一是没有找到a或者b，则返回NULL；二是只要碰到a或者b，就立刻返回。

## 二、算法真题

### 回文数判断(不能用字符串，不能申请额外空间)

如果一个数字正着和倒着都是一样的就称这个数字是回文数,如12321是回文数,个位与万位相同,十位与千位相同。 现在给出一个数判断是否是回文数。

输入描述

```
输入包括一行：一个非负整数n
```

输出描述

```
如果是回文数输出"This is a palindrome number!",如果不是回文数输出"This is not a palindrome number!"
```

示例1

**输入**

```
123
```

**输出**

```
This is not a palindrome number!
```

答:

```java
public boolean isPalindrome(int x) {
  int reverse = 0;
  int tmp = x;
  //数字反转操作
  while(tmp != 0){
    reverse = reverse * 10 + tmp % 10;
    tmp = tmp /10;
  }
  return reverse == x;
}
```

## 删除单向链表中倒数第K个位置。能否做到一次循环？(字节跳动)
```java
class ListNode{
    ListNode next;
    int data;
}
```

```kotlin
/**
 * 删除单向链表中的第K个节点
 *
 * @param head 单向链表
 * @param k 删除倒数第k个节点
 */
private fun deleteReverseNode(head: ListNode?, k: Int) {
    var t: ListNode? = head
    val list = arrayListOf<ListNode>()
    while (t != null) {
        list.add(t)
        t = t.next
    }
    list[list.size - k - 1].next = list[list.size - k + 1]
}
```


## 三、智力题


### 1 玩一个游戏，54张牌，2个人玩，每人每次只能拿1~3张牌，你先拿，你会采取怎么样的策略？

第一次，我拿2张。

第二次你拿，第三次我拿。这一次算第一轮。确保这一轮拿4张。(即你拿1张时，我拿3张；你拿2张时，我拿两张；你拿3张时，我拿1张)

之后的每轮都是确保拿4张。

最后一轮刚好还是我拿到了底牌。(因为(54-2)/4=13，正好整除)

拓展问题：我后拿，如何保证拿到底牌？

1 1 52/4=13

2 3 可能就赢不了了。

3 3 48/4=12

之后的策略与上面一致。

### 2 赛马

>一共有25匹马，赛马场有5条跑道。
>你手上没有计时工具，只能通过比赛看出哪匹马跑得比哪匹马快，并不知道绝对速度。
>每匹马每次出场的状态一样。（马A跑得比马B快，无论比多少次都是这个结果。每匹马的速度是一定的，不变的）
>求：至少比多少场才能得出跑得最快的三匹马。

答：**7场**。每5匹一组，5场。每组获胜的马，再比一场，第6场。第6场获得第一名的马就是25匹马里最快的那匹。剩下还有可能是第二名、第三名的马有：**第6场的第二、三名，第6场的第一名（25匹里的冠军）之前所在组的第二、三名，第6场的第二名之前所在组的第二名**。这里正好又凑齐5匹马，再比一场。**第7场**的第一二名就是，25匹马的亚军和季军。

### 3 称重
> 有一个天平, 有一个1000g重的物体，可以将它分为若干个整数重的小物体（作为砝码），要求这些砝码可以称出1~1000g以内任意重的物体。砝码只能放一边，求砝码数最少的分法。

答：**1 2 4 8 16 32 64 128 256 489**。理由：**二进制**。

进阶：
> 砝码能放两边，求同样的问题。（比如我有重量分别为1、3、5的砝码，就可以称出重量为1、2、3、4、5、6、7、8、9的物体）

答：**1 3 9 27 81 243 636**。理由：我是**递推**出来的。从最小的开始，能称1g的物体必须要有一个1g的砝码。然后1g能称了，接着就要称2g。你可以再来个1g的也可以再来个2g的或者3g的，但是三者比较之下，加个3g的不仅能称2g还可以称3、4g，比加个1、2g划算。由此可见，只需将前面的砝码重量*2+1及可以得到下一个最“划算”的砝码重量。1、3已经可以称1~4g的物体，接下来要称5g。那就4+5=9。下一个砝码切成9g最划算。差不多可以总结规律了，就是**3的整数次幂等比序列**。


